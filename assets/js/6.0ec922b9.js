(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{326:function(t,s,n){"use strict";n.r(s);var a=n(33),e=Object(a.a)({},(function(){var t=this,s=t.$createElement,n=t._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"栈"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[t._v("#")]),t._v(" 栈")]),t._v(" "),n("p",[t._v("栈是一种特殊的线性表， 仅能够在栈顶进行操作， 有着先进后出的特性。")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/4/20/171981f64fc98912",alt:""}})]),t._v(" "),n("h3",{attrs:{id:"栈的简单实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#栈的简单实现"}},[t._v("#")]),t._v(" 栈的简单实现")]),t._v(" "),n("ul",[n("li",[t._v("实现栈可以有两种方式，一种是以数组做基础；一种是以链表做基础。")]),t._v(" "),n("li",[t._v("栈的方法\n"),n("ul",[n("li",[t._v("push (添加一个元素到栈顶)")]),t._v(" "),n("li",[t._v("pop (弹出栈顶元素)")]),t._v(" "),n("li",[t._v("top (返回栈顶元素， 注意不是弹出)")]),t._v(" "),n("li",[t._v("isEmpty (判断栈是否为空)")]),t._v(" "),n("li",[t._v("size (返回栈里元素的个数)")]),t._v(" "),n("li",[t._v("clear (清空栈)")])])])]),t._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/Been101/data-structure/blob/master/Stack/Stack.js",target:"_blank",rel:"noopener noreferrer"}},[t._v("以数组为基础的完整代码实现"),n("OutboundLink")],1)]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function Stack {\n    var items = []\n    this.push = function (item) {\n        items.push(item)\n    }\n    this.pop = function() {\n        return items.pop()\n    }\n    this.top = function() {\n        return items[items.length - 1]\n    }\n    this.isEmpty = function() {\n        return !items.length\n    }\n    this.size = function () {\n        return items.length\n    }\n    this.clear = function() {\n        items = []\n    }\n}\n")])])]),n("h3",{attrs:{id:"应用练习"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#应用练习"}},[t._v("#")]),t._v(" 应用练习")]),t._v(" "),n("ol",[n("li",[t._v("编写一个函数判断字符串中的括号是否合法, 所谓合法，就是括号成对出现。")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("sff()sf(sasfa)sfa(sdfsfd(sf))   合法\n((asf)sf(af)fa)                 合法\n)(sfa)f                         不合法\n(saf))fafa(sss()                不合法\n")])])]),n("p",[t._v("思路分析：")]),t._v(" "),n("ul",[n("li",[t._v("for循环遍历字符串每一个字符")]),t._v(" "),n("li",[t._v("遇到左括号(, 就把左括号压入栈中")]),t._v(" "),n("li",[t._v("遇到右括号，判断栈是否为空， 为空说明没有左括号与之对应， 缺少左括号， 字符串括号不合法，如果栈不为空，则把栈顶元素弹出，这对括号抵消掉")]),t._v(" "),n("li",[t._v("for 循环结束之后， 如果栈是空的， 说明左右括号抵消掉了，字符串合法。如果栈里还有元素，则说明缺少右括号，字符串不合法")])]),t._v(" "),n("p",[n("code",[t._v("代码实现")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function is_leagl_brackets(str) {\n    let stack = new Stack()\n    for(let i = 0; i < str.length; i++) {\n        const item = str[i]\n        if(item === '(') {\n            stack.push(item)\n        }\n        if(item === ')') {\n            if(stack.isEmpty()) {\n                return false\n            }else {\n                stack.pop()\n            }\n        }\n    }\n    \n    return stack.isEmpty()\n}\n")])])]),n("ol",{attrs:{start:"2"}},[n("li",[t._v("逆波兰表达式")])]),t._v(" "),n("p",[t._v("也叫后缀表达式，它将复杂表达式转换为可以依靠简单的操作得到计算结果的表达式， 例如 (a + b) * (c + d) 转换为a b + c d + *")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('["4", "13", "5", "/", "+"] 等价于(4 + (13 / 5)) = 6\n["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"] 等价于((10 *\t\n(6/((9 + 3) * -11 ))) + 17) + 5\n')])])]),n("p",[t._v("思路：")]),t._v(" "),n("p",[t._v("for 循环遍历数组，对每一个元素做如下操作")]),t._v(" "),n("ul",[n("li",[t._v("如果元素不是 + - * / 中某一个，直接压入栈。")]),t._v(" "),n("li",[t._v("如果是 + - / *中的一个，则连续弹出两个元素，并对这两个元素进行计算，且第一元素在运算符右侧， 第二个在运算符左侧，并把计算结果压入栈。")])]),t._v(" "),n("p",[t._v("for 循环结束后， 栈里只有一个元素， 则这个元素就是整个表达式的计算结果。")]),t._v(" "),n("p",[n("code",[t._v("代码实现")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const operators = ['+', '-', '*', '/']\nfunction calc_exp(exp_arr){\n    const stack = new Stack()\n    for(let i = 0; i < exp_arr.length; i++) {\n        const item = exp_arr[i]\n        if(operators.includes(item)) {\n            // 从栈顶弹出连个元素\n            const val1 = stack.pop()\n            const val2 = stack.pop()\n            // 拼成表达式\n            const str = val2 + item + val1\n            const result = parseInt(eval(str))\n            // 将计算结果转成字符串并压入栈\n            stack.push(result.toString())\n        }else {\n            stack.push(item)\n        }\n    }\n    // for 循环结束， 栈里只有一个元素， 就是最终的结果。\n    return stack.pop()\n}\n\n")])])])])}),[],!1,null,null,null);s.default=e.exports}}]);